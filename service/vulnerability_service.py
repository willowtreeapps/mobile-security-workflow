from service.input_service import execute_command
from service import output_service
from datetime import datetime
from service import db_service
import os

""""

    File responsible to manage all the vulnerability-related stuff

"""

rules = []
vulnerabilities = []

def search_sqlite(sensitive_data, package):
    databases_path = f"/data/data/{package}/databases"

    content = execute_command(f"adb shell ls {databases_path}")

    if content:
        files = content.split()
        for file in files:
            file_path = f"{databases_path}/{file}"

            #  -   get the database file from device to the actual environment
            execute_command(f"adb pull {file_path} .")            

            result = db_service.search_for_data(f"{file}", sensitive_data)

            #  -  result[0] = boolean within the result
            if result is not None and result[0]:
                    print(f"[+] Sensitive data '{sensitive_data}' were found in sqlite")        

                    INSECURE_STORAGE_SQLITE_CWE = os.getenv("INSECURE_STORAGE_SQLITE_CWE")
                    INSECURE_STORAGE_SQLITE_RULE_ID = os.getenv("INSECURE_STORAGE_SQLITE_RULE_ID")
                    INSECURE_STORAGE_SQLITE_SEV = os.getenv("INSECURE_STORAGE_SQLITE_SEV")
                    INSECURE_STORAGE_SQLITE_NAME = os.getenv("INSECURE_STORAGE_SQLITE_NAME")      
                    INSECURE_STORAGE_SQLITE_REMEDIATION = os.getenv("INSECURE_STORAGE_SQLITE_REMEDIATION")
                    INSECURE_STORAGE_SQLITE_PRECISION = os.getenv("INSECURE_STORAGE_SQLITE_PRECISION")                

                    add_vulnerability(INSECURE_STORAGE_SQLITE_RULE_ID,
                                    INSECURE_STORAGE_SQLITE_NAME,
                                    INSECURE_STORAGE_SQLITE_SEV,
                                    INSECURE_STORAGE_SQLITE_PRECISION,
                                    INSECURE_STORAGE_SQLITE_CWE,
                                    result[1], # -  string content with the sensitive data
                                    INSECURE_STORAGE_SQLITE_REMEDIATION)

                    print(f"[+] Vulnerability [{INSECURE_STORAGE_SQLITE_NAME}] Added")                     

    return

def search_shared_pref(data, package):   

    output = execute_command(f"adb shell grep -r '{data}' /data/data/{package}/shared_prefs")
 
    if output:
        print(f"[+] Sensitive data '{data}' were found in shared preferences")        

        INSECURE_STORAGE_SP_CWE = os.getenv("INSECURE_STORAGE_SP_CWE")
        INSECURE_STORAGE_SP_RULE_ID = os.getenv("INSECURE_STORAGE_SP_RULE_ID")
        INSECURE_STORAGE_SP_SEV = os.getenv("INSECURE_STORAGE_SP_SEV")
        INSECURE_STORAGE_SP_NAME = os.getenv("INSECURE_STORAGE_SP_NAME")      
        INSECURE_STORAGE_SP_REMEDIATION = os.getenv("INSECURE_STORAGE_SP_REMEDIATION")
        INSECURE_STORAGE_SP_PRECISION = os.getenv("INSECURE_STORAGE_SP_PRECISION")                

        add_vulnerability(INSECURE_STORAGE_SP_RULE_ID,
                          INSECURE_STORAGE_SP_NAME,
                          INSECURE_STORAGE_SP_SEV,
                          INSECURE_STORAGE_SP_PRECISION,
                          INSECURE_STORAGE_SP_CWE,
                          output,
                          INSECURE_STORAGE_SP_REMEDIATION)

        print(f"[+] Vulnerability [{INSECURE_STORAGE_SP_NAME}] Added") 

def search_sensitive_log(data):   
   
    #           use logcat to see the last device's log entries
    #           compare with sensitive data and retrieve the 6 last rows
    output = execute_command(f"adb logcat -d | grep {data} | tail -n 10") 

    if output:
        print(f"[+] Sensitive data '{data}' were found in logs")        

        INSECURE_LOGGING_CWE = os.getenv("INSECURE_LOGGING_CWE")
        INSECURE_LOGGING_RULE_ID = os.getenv("INSECURE_LOGGING_RULE_ID")
        INSECURE_LOGGING_SEV = os.getenv("INSECURE_LOGGING_SEV")
        INSECURE_LOGGING_NAME = os.getenv("INSECURE_LOGGING_NAME")      
        INSECURE_LOGGING_REMEDIATION = os.getenv("INSECURE_LOGGING_REMEDIATION")
        INSECURE_LOGGING_PRECISION = os.getenv("INSECURE_LOGGING_PRECISION")                

        add_vulnerability(INSECURE_LOGGING_RULE_ID,
                          INSECURE_LOGGING_NAME,
                          INSECURE_LOGGING_SEV,
                          INSECURE_LOGGING_PRECISION,
                          INSECURE_LOGGING_CWE,
                          output,
                          INSECURE_LOGGING_REMEDIATION)

        print(f"[+] Vulnerability [{INSECURE_LOGGING_NAME}] Added")       

def get_vulnerabilities():
    return vulnerabilities

# -     Check of the app is still running     -
def is_app_running(package):        
    output = execute_command(f"adb shell ps | grep {package}")
    if package in output:
        return True
    return False

def is_emulated_device():
    # -     Common Emulators Sources     -
    emulators = [
        "ranchu",
        "goldfish",
        "vbox86",
        "qemu"
    ]
    output = execute_command("adb shell getprop ro.hardware")
    output = f"[-] getprop ro.hardware: {output}"

    if any(word in output for word in emulators):                
        return True, output
    return False

#
# -     Checks for Emulator Detection     -
#
def check_emulator(package):
    is_emulator =  is_emulated_device()
    emulator_str = "emula"

    if is_emulator[0]:
        #   -  if the app is not running. We asume that the application doesnt allow to run on emulators
        if not is_app_running(package):
            print("[-] App is not running")
            return
        
        output_screen = dump_screen(emulator_str)

        if (emulator_str in output_screen):
            print("[-] Emulator advise is being used")
            return
        
        EMULATOR_DETECTION_CWE = os.getenv("EMULATOR_DETECTION_CWE")
        EMULATOR_DETECTION_RULE_ID = os.getenv("EMULATOR_DETECTION_RULE_ID")
        EMULATOR_DETECTION_SEV = os.getenv("EMULATOR_DETECTION_SEV")
        EMULATOR_DETECTION_NAME = os.getenv("EMULATOR_DETECTION_NAME")      
        EMULATOR_DETECTION_REMEDIATION = os.getenv("EMULATOR_DETECTION_REMEDIATION")
        EMULATOR_DETECTION_PRECISION = os.getenv("EMULATOR_DETECTION_PRECISION")

        #@todo check if is possible to make a screenshot and print on github

        add_vulnerability(EMULATOR_DETECTION_RULE_ID,
                          EMULATOR_DETECTION_NAME,
                          EMULATOR_DETECTION_SEV,
                          EMULATOR_DETECTION_PRECISION,
                          EMULATOR_DETECTION_CWE,
                          is_emulator[1], #output str of emulator verification
                          EMULATOR_DETECTION_REMEDIATION)

        print(f"[+] Vulnerability [{EMULATOR_DETECTION_NAME}] Added")


"""
    this function uses a tool that read the ui elements to search specific content/text/data
"""
def dump_screen(data):
    filename = f"ui_dump_{datetime.now()}.xml"
    execute_command(f"adb shell uiautomator dump /sdcard/{filename}")
    return execute_command(f"adb shell cat /sdcard/{filename} | grep {data}")

#
# -     CHECKS FOR ROOT DETECTION     -
#
def check_root(package):
    root_str = "root"
    is_rooted = is_rooted_device()

    if is_rooted[0]:
        #   -  if the app is not running. We asume that the application doesnt allow to run on rooted devices
        if not is_app_running(package):
            print("[-] App is not running")
            return

        output_screen = dump_screen(root_str)

        if (root_str in output_screen):
            print("[-] Root advise is being used")
            return
        
        ROOT_DETECTION_CWE = os.getenv("ROOT_DETECTION_CWE")
        ROOT_DETECTION_RULE_ID = os.getenv("ROOT_DETECTION_RULE_ID")
        ROOT_DETECTION_SEV = os.getenv("ROOT_DETECTION_SEV")
        ROOT_DETECTION_NAME = os.getenv("ROOT_DETECTION_NAME")      
        ROOT_DETECTION_REMEDIATION = os.getenv("ROOT_DETECTION_REMEDIATION")
        ROOT_DETECTION_PRECISION = os.getenv("ROOT_DETECTION_PRECISION")     

        #@todo check if is possible to make a screenshot and print on github

        add_vulnerability(ROOT_DETECTION_RULE_ID,
                          ROOT_DETECTION_NAME,
                          ROOT_DETECTION_SEV,
                          ROOT_DETECTION_PRECISION,
                          ROOT_DETECTION_CWE,
                          is_rooted[1], # output str of root verification
                          ROOT_DETECTION_REMEDIATION)

        print(f"[+] Vulnerability [{ROOT_DETECTION_NAME}] Added")       

def is_rooted_device():
    output = execute_command("adb shell whoami")
    output = f"[-] whoami: {output}"
    
    if "root" in output:
        return True, output
    return False

def add_vulnerability(rule_id, name, severity, precision, cwe, evidence, remediation):        
        evidence_piece = f"```java\n{evidence}```\n"     
        remediation = f"{remediation}{evidence_piece}"
        
        #        define the rule. Each vulnerability need one to 
        #        have the fix details and additional information     
        rule = {
            "id":rule_id,
            "name": name,
            "shortDescription":{
                "text": name,
            },              
            "help": {
                "text": remediation
              },                            
              "properties": {
                "security-severity": severity,
                "precision": precision,
                "tags": ["security", cwe, "mobile", "dynamic"]
              }
        }
        #        define the vulnerability itself
        vulnerability = {
          "ruleId": rule_id,
          "message": {
            "text": name,
          },
          "level":"error", 
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "app.apk", # -  it requires at least one location, we point to this generic one
                  "uriBaseId": "SRCROOT"
                }               
              }
            }
          ]         
        }


        if rule not in rules:            
            rules.append(rule)
        
        vulnerabilities.append(vulnerability) 


def build_report():
    print("[*] Building report ..")
    output_service.build_output(rules, vulnerabilities)

def create_ssl_vul(data):
    print("[+] Creating SSL Pinning vulnerability")    
    
    title = "// * Intercepted Request:"
    headers = data['headers']            
    evidence = f"{title}".join(headers)
    
    print("[+] Evidence")
    print(evidence)

    SSL_PINNING_CWE = os.getenv("SSL_PINNING_CWE")
    SSL_PINNING_RULE_ID = os.getenv("SSL_PINNING_RULE_ID")
    SSL_PINNING_SEV = os.getenv("SSL_PINNING_SEV")
    SSL_PINNING_NAME = os.getenv("SSL_PINNING_NAME")      
    SSL_PINNING_REMEDIATION = os.getenv("SSL_PINNING_REMEDIATION")
    SSL_PINNING_PRECISION = os.getenv("SSL_PINNING_PRECISION")     

    add_vulnerability(SSL_PINNING_RULE_ID,
                          SSL_PINNING_NAME,
                          SSL_PINNING_SEV,
                          SSL_PINNING_PRECISION,
                          SSL_PINNING_CWE,
                          evidence,
                          SSL_PINNING_REMEDIATION)

    print(f"[+] Vulnerability [{SSL_PINNING_NAME}] Added")      