from service.input_service import execute_command
from service import output_service
from service import db_service
from common import helper
import os
import json

""""

    File responsible to manage all the vulnerability-related stuff

"""

rules = []
vulnerabilities = []

def search_sqlite(sensitive_data, package):
    databases_path = f"/data/data/{package}/databases"    

    content = execute_command(f"adb shell ls {databases_path}")

    if content:
        files = content.split()
        for file in files:
            file_path = f"{databases_path}/{file}"

            #  -   get the database file from device to the actual environment
            execute_command(f"adb pull {file_path} .")            

            result = db_service.search_for_data(f"{file}", file_path, sensitive_data)

            #  -  result[0] = boolean within the result
            if result is not None and result[0]:
                    print(f"[+] Sensitive data '{sensitive_data}' were found in sqlite")        

                    INSECURE_STORAGE_SQLITE_CWE = os.getenv("INSECURE_STORAGE_SQLITE_CWE")
                    INSECURE_STORAGE_SQLITE_RULE_ID = os.getenv("INSECURE_STORAGE_SQLITE_RULE_ID")
                    INSECURE_STORAGE_SQLITE_SEV = os.getenv("INSECURE_STORAGE_SQLITE_SEV")
                    INSECURE_STORAGE_SQLITE_NAME = os.getenv("INSECURE_STORAGE_SQLITE_NAME")      
                    INSECURE_STORAGE_SQLITE_REMEDIATION = os.getenv("INSECURE_STORAGE_SQLITE_REMEDIATION")
                    INSECURE_STORAGE_SQLITE_PRECISION = os.getenv("INSECURE_STORAGE_SQLITE_PRECISION")                

                    add_vulnerability(INSECURE_STORAGE_SQLITE_RULE_ID,
                                    INSECURE_STORAGE_SQLITE_NAME,
                                    INSECURE_STORAGE_SQLITE_SEV,
                                    INSECURE_STORAGE_SQLITE_PRECISION,
                                    INSECURE_STORAGE_SQLITE_CWE,
                                    result[1], # -  string content with the sensitive data
                                    INSECURE_STORAGE_SQLITE_REMEDIATION)

                    print(f"[+] Vulnerability [{INSECURE_STORAGE_SQLITE_NAME}] Added")                     

    return

def search_shared_pref(data, package):   

    output = execute_command(f"adb shell grep -r '{data}' /data/data/{package}/shared_prefs")
 
    if output:
        print(f"[+] Sensitive data '{data}' were found in shared preferences")        

        INSECURE_STORAGE_SP_CWE = os.getenv("INSECURE_STORAGE_SP_CWE")
        INSECURE_STORAGE_SP_RULE_ID = os.getenv("INSECURE_STORAGE_SP_RULE_ID")
        INSECURE_STORAGE_SP_SEV = os.getenv("INSECURE_STORAGE_SP_SEV")
        INSECURE_STORAGE_SP_NAME = os.getenv("INSECURE_STORAGE_SP_NAME")      
        INSECURE_STORAGE_SP_REMEDIATION = os.getenv("INSECURE_STORAGE_SP_REMEDIATION")
        INSECURE_STORAGE_SP_PRECISION = os.getenv("INSECURE_STORAGE_SP_PRECISION")                

        add_vulnerability(INSECURE_STORAGE_SP_RULE_ID,
                          INSECURE_STORAGE_SP_NAME,
                          INSECURE_STORAGE_SP_SEV,
                          INSECURE_STORAGE_SP_PRECISION,
                          INSECURE_STORAGE_SP_CWE,
                          output,
                          INSECURE_STORAGE_SP_REMEDIATION)

        print(f"[+] Vulnerability [{INSECURE_STORAGE_SP_NAME}] Added") 

def search_sensitive_log(data):   
   
    #           use logcat to see the last device's log entries
    #           compare with sensitive data and retrieve the 6 last rows
    output = execute_command(f"adb logcat -d | grep {data} | tail -n 10") 

    if output:
        print(f"[+] Sensitive data '{data}' were found in logs")        

        INSECURE_LOGGING_CWE = os.getenv("INSECURE_LOGGING_CWE")
        INSECURE_LOGGING_RULE_ID = os.getenv("INSECURE_LOGGING_RULE_ID")
        INSECURE_LOGGING_SEV = os.getenv("INSECURE_LOGGING_SEV")
        INSECURE_LOGGING_NAME = os.getenv("INSECURE_LOGGING_NAME")      
        INSECURE_LOGGING_REMEDIATION = os.getenv("INSECURE_LOGGING_REMEDIATION")
        INSECURE_LOGGING_PRECISION = os.getenv("INSECURE_LOGGING_PRECISION")                

        add_vulnerability(INSECURE_LOGGING_RULE_ID,
                          INSECURE_LOGGING_NAME,
                          INSECURE_LOGGING_SEV,
                          INSECURE_LOGGING_PRECISION,
                          INSECURE_LOGGING_CWE,
                          output,
                          INSECURE_LOGGING_REMEDIATION)

        print(f"[+] Vulnerability [{INSECURE_LOGGING_NAME}] Added")       

def get_vulnerabilities():
    return vulnerabilities

# -     Check of the app is still running     -
def is_app_running(package):        
    output = execute_command(f"adb shell ps | grep {package}")
    if package in output:
        return True
    return False

def is_emulated_device():
    # -     Common Emulators Sources     -
    emulators = [
        "ranchu",
        "goldfish",
        "vbox86",
        "qemu"
    ]
    output = execute_command("adb shell getprop ro.hardware")
    output = f"[-] getprop ro.hardware: {output}"

    if any(word in output for word in emulators):                
        return True, output
    return False

#
# -     Checks for Emulator Detection     -
#
def check_emulator(package):
    is_emulator =  is_emulated_device()
    emulator_str = "emula"

    if is_emulator[0]:
        #   -  if the app is not running. We asume that the application doesnt allow to run on emulators
        if not is_app_running(package):
            print("[-] App is not running")
            return
        
        output_screen = dump_screen()
        output_screen = output_screen.lower()

        if (emulator_str in output_screen):
            print("[-] Emulator advise is being used")
            return
        
        EMULATOR_DETECTION_CWE = os.getenv("EMULATOR_DETECTION_CWE")
        EMULATOR_DETECTION_RULE_ID = os.getenv("EMULATOR_DETECTION_RULE_ID")
        EMULATOR_DETECTION_SEV = os.getenv("EMULATOR_DETECTION_SEV")
        EMULATOR_DETECTION_NAME = os.getenv("EMULATOR_DETECTION_NAME")      
        EMULATOR_DETECTION_REMEDIATION = os.getenv("EMULATOR_DETECTION_REMEDIATION")
        EMULATOR_DETECTION_PRECISION = os.getenv("EMULATOR_DETECTION_PRECISION")

        #@todo check if is possible to make a screenshot and print on github

        add_vulnerability(EMULATOR_DETECTION_RULE_ID,
                          EMULATOR_DETECTION_NAME,
                          EMULATOR_DETECTION_SEV,
                          EMULATOR_DETECTION_PRECISION,
                          EMULATOR_DETECTION_CWE,
                          is_emulator[1], #output str of emulator verification
                          EMULATOR_DETECTION_REMEDIATION)

        print(f"[+] Vulnerability [{EMULATOR_DETECTION_NAME}] Added")


"""
    this function uses a tool that read the ui elements to search specific content/text/data
"""
def dump_screen():    
    execute_command(f"adb shell uiautomator dump")
    return execute_command(f"adb shell cat /sdcard/window_dump.xml") # - this is the default path for uidump output

#
# -     CHECKS FOR ROOT DETECTION     -
#
def check_root(package):
    root_str = "rooted"
    is_rooted = is_rooted_device()

    if is_rooted[0]:
        #   -  if the app is not running. We asume that the application doesnt allow to run on rooted devices
        if not is_app_running(package):
            print("[-] App is not running")
            return

        output_screen = dump_screen()
        output_screen = output_screen.lower()

        if (root_str in output_screen):
            print("[-] Root advise is being used")
            return
        
        ROOT_DETECTION_CWE = os.getenv("ROOT_DETECTION_CWE")
        ROOT_DETECTION_RULE_ID = os.getenv("ROOT_DETECTION_RULE_ID")
        ROOT_DETECTION_SEV = os.getenv("ROOT_DETECTION_SEV")
        ROOT_DETECTION_NAME = os.getenv("ROOT_DETECTION_NAME")      
        ROOT_DETECTION_REMEDIATION = os.getenv("ROOT_DETECTION_REMEDIATION")
        ROOT_DETECTION_PRECISION = os.getenv("ROOT_DETECTION_PRECISION")     

        #@todo check if is possible to make a screenshot and print on github

        add_vulnerability(ROOT_DETECTION_RULE_ID,
                          ROOT_DETECTION_NAME,
                          ROOT_DETECTION_SEV,
                          ROOT_DETECTION_PRECISION,
                          ROOT_DETECTION_CWE,
                          is_rooted[1], # output str of root verification
                          ROOT_DETECTION_REMEDIATION)

        print(f"[+] Vulnerability [{ROOT_DETECTION_NAME}] Added")       

def is_rooted_device():
    output = execute_command("adb shell whoami")
    output = f"[-] whoami: {output}"
    
    if "root" in output:
        return True, output
    return False

def add_vulnerability(rule_id, name, severity, precision, cwe, evidence, remediation):        
        evidence_piece = f"```java\n{evidence}```\n"     
        remediation = f"{remediation}{evidence_piece}"
        
        #        define the rule. Each vulnerability need one to 
        #        have the fix details and additional information     
        rule = {
            "id":rule_id,
            "name": name,
            "shortDescription":{
                "text": name,
            },              
            "help": {
                "text": remediation
              },                            
              "properties": {
                "security-severity": severity,
                "precision": precision,
                "tags": ["security", cwe, "mobile", "dynamic"]
              }
        }
        #        define the vulnerability itself
        vulnerability = {
          "ruleId": rule_id,
          "message": {
            "text": name,
          },
          "level":"error", 
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "app.apk", # -  it requires at least one location, we point to this generic one
                  "uriBaseId": "SRCROOT"
                }               
              }
            }
          ]         
        }

        if any(r['id'] == rule['id'] for r in rules):
            print(f"[DEBUG] Rule already created {rule['id']}")
        else:
            rules.append(rule)  
            vulnerabilities.append(vulnerability)                           
                                         

def build_report():
    print("[*] Building report ..")
    print(f"[DEBUG] Rules: {rules}")
    print(f"[DEBUG] Vulnerabilities: {vulnerabilities}")
    output_service.build_output(rules, vulnerabilities)
    
def build_severity(severity_str):    
    severity_str = severity_str
    if severity_str == "Critical":
        return str(10.0)
    elif severity_str == "High":
        return str(8.0)
    elif severity_str == "Medium":
        return str(6.0)
    elif severity_str == "Low":
        return str(3.0)
    else:
        return str(0)

def build_confidence(confidence_str):
    confidence_str = confidence_str
    if confidence_str == "Certain":
        return "high"
    elif confidence_str == "Firm":
        return "medium"
    elif confidence_str == "Tentative":
        return "low"
    else:
        return "unknown"

def build_generic_rule_id(name):
    return f"dynamic-b-{name.lower().replace(' ', '-')}"    
    
def create_generic_vul(data):
    print("[+] Creating Generic vulnerability")            
    
    name = data['name']
    description = data['detail']
    confidence = data['confidence']
    severity = data['severity']
    remediation = data['remediationBackground']
    
    risk = data['issueBackground']
    
    # First parse requestData which is a JSON string
    request_data = json.loads(data['requestData'])
    
    # Then parse the nested request and response
    request_info = json.loads(request_data['request'])
    request_headers = request_info['headers']
    
    evidence = "\n//--- Request: ---\n" + request_headers
    
    if(request_data.get('response') is not None):
        response_info = json.loads(request_data['response'])
        response_headers = response_info['headers']
        evidence = "//--- Request ---\n" + request_headers + "\n//--- Response ---\n" + response_headers           

    recommendation = f" \n\n### Description\n\n {description} \n\n### Risk\n\n {risk} \n\n### Recommendation\n\n {remediation} \n\n ### Evidence\n"      
    
    rule_id = build_generic_rule_id(name)
        
    add_vulnerability(
                    rule_id,
                    name,
                    build_severity(severity),
                    build_confidence(confidence),
                    "external/cwe/cwe-200", 
                    evidence,
                    recommendation)
    
    print(f"[+] Vulnerability [{name}] Added")

def create_ssl_vul(data):
    print("[+] Creating SSL Pinning vulnerability")    
    
    title = "// Intercepted Request: \n"
    headers = data['headers']    
    host = data['host']
    path = data['path']        
    evidence = title + f"".join(headers)
    request_id = helper.make_hash(host+path)

    SSL_PINNING_CWE = os.getenv("SSL_PINNING_CWE")
    SSL_PINNING_RULE_ID = os.getenv("SSL_PINNING_RULE_ID")
    SSL_PINNING_SEV = os.getenv("SSL_PINNING_SEV")
    SSL_PINNING_NAME = os.getenv("SSL_PINNING_NAME")      
    SSL_PINNING_REMEDIATION = os.getenv("SSL_PINNING_REMEDIATION")
    SSL_PINNING_PRECISION = os.getenv("SSL_PINNING_PRECISION")     
        
    rule_id = f"{SSL_PINNING_RULE_ID}-{request_id}"
    
    add_vulnerability(rule_id,
                    SSL_PINNING_NAME,
                    SSL_PINNING_SEV,
                    SSL_PINNING_PRECISION,
                    SSL_PINNING_CWE,
                    evidence,
                    SSL_PINNING_REMEDIATION)

    print(f"[+] Vulnerability [{SSL_PINNING_NAME}] Added")
    
    
def search_sensitive_external(data):   
   
    #           use find to search recursively on /sdcard files
    output = execute_command(f'adb shell \'find /sdcard/ -type f -exec grep -H "{data}" "{{}}" \\;\'')        

    if output:
        print(f"[+] Sensitive data '{data}' were found in sdcard")        

        INSECURE_STORAGE_SDCARD_CWE = os.getenv("INSECURE_STORAGE_SDCARD_CWE")
        INSECURE_STORAGE_SDCARD_RULE_ID = os.getenv("INSECURE_STORAGE_SDCARD_RULE_ID")
        INSECURE_STORAGE_SDCARD_SEV = os.getenv("INSECURE_STORAGE_SDCARD_SEV")
        INSECURE_STORAGE_SDCARD_NAME = os.getenv("INSECURE_STORAGE_SDCARD_NAME")      
        INSECURE_STORAGE_SDCARD_REMEDIATION = os.getenv("INSECURE_STORAGE_SDCARD_REMEDIATION")
        INSECURE_STORAGE_SDCARD_PRECISION = os.getenv("INSECURE_STORAGE_SDCARD_PRECISION")                

        add_vulnerability(INSECURE_STORAGE_SDCARD_RULE_ID,
                          INSECURE_STORAGE_SDCARD_NAME,
                          INSECURE_STORAGE_SDCARD_SEV,
                          INSECURE_STORAGE_SDCARD_PRECISION,
                          INSECURE_STORAGE_SDCARD_CWE,
                          output,
                          INSECURE_STORAGE_SDCARD_REMEDIATION)

        print(f"[+] Vulnerability [{INSECURE_STORAGE_SDCARD_NAME}] Added")  
            

